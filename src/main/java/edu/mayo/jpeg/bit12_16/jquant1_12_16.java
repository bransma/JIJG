package edu.mayo.jpeg.bit12_16;

import edu.mayo.jpeg.bit12_16.error12_16.ErrorStrings12_16;
import edu.mayo.jpeg.bit12_16.structs12_16.jpeg_color_quantizer12_16;
import edu.mayo.jpeg.bit12_16.structs12_16.jpeg_decompress_struct12_16;

/*
 * jquant1.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains 1-pass color quantization (color mapping) routines.
 * These routines provide mapping to a fixed color map using equally spaced
 * color values.  Optional Floyd-Steinberg or ordered dithering is available.
 */

/*
 * The main purpose of 1-pass quantization is to provide a fast, if not very
 * high quality, colormapped output capability.  A 2-pass quantizer usually
 * gives better visual quality; however, for quantized grayscale output this
 * quantizer is perfectly adequate.  Dithering is highly recommended with this
 * quantizer, though you can turn it off if you really want to.
 *
 * In 1-pass quantization the colormap must be chosen in advance of seeing the
 * image.  We use a map consisting of all combinations of Ncolors[i] color
 * values for the i'th component.  The Ncolors[] values are chosen so that
 * their product, the total number of colors, is no more than that requested.
 * (In most cases, the product will be somewhat less.)
 *
 * Since the colormap is orthogonal, the representative value for each color
 * component can be determined without considering the other components;
 * then these indexes can be combined into a colormap index by a standard
 * N-dimensional-array-subscript calculation.  Most of the arithmetic involved
 * can be precalculated and stored in the lookup table colorindex[].
 * colorindex[i][j] maps pixel value j in component i to the nearest
 * representative value (grid plane) for that component; this index is
 * multiplied by the array stride for component i, so that the
 * index of the colormap entry closest to a given pixel value is just
 *    sum( colorindex[component-number][pixel-component-value] )
 * Aside from being fast, this scheme allows for variable spacing between
 * representative values with no additional lookup cost.
 *
 * If gamma correction has been applied in color conversion, it might be wise
 * to adjust the color grid spacing so that the representative colors are
 * equidistant in linear space.  At this writing, gamma correction is not
 * implemented by jdcolor, so nothing is done here.
 */

public class jquant1_12_16 extends jpeg_color_quantizer12_16
{
    /* Declarations for ordered dithering.
     *
     * We use a standard 16x16 ordered dither array.  The basic concept of ordered
     * dithering is described in many references, for instance Dale Schumacher's
     * chapter II.2 of Graphics Gems II (James Arvo, ed. Academic Press, 1991).
     * In place of Schumacher's comparisons against a "threshold" value, we add a
     * "dither" value to the input pixel and then round the result to the nearest
     * output value.  The dither value is equivalent to (0.5 - threshold) times
     * the distance between output values.  For ordered dithering, we assume that
     * the output colors are equally spaced; if not, results will probably be
     * worse, since the dither may be too much or too little at a given point.
     *
     * The normal calculation would be to form pixel value + dither, range-limit
     * this to 0..jmorecfg.MAXJSAMPLE, and then index into the colorindex table as usual.
     * We can skip the separate range-limiting step by extending the colorindex
     * table in both directions.
     */

    public static final int MAX_Q_COMPS = 4;
    public static final int ODITHER_SIZE = 16; /* dimension of dither matrix */
    public static final int ODITHER_CELLS = ODITHER_SIZE * ODITHER_SIZE;
    public static final int ODITHER_MASK = ODITHER_SIZE - 1;

    public static final int[][] base_dither_matrix = {
            /* Bayer's order-4 dither array.  Generated by the code given in
             * Stephen Hawley's article "Ordered Dithering" in Graphics Gems I.
             * The values in this array must range from 0 to ODITHER_CELLS-1.
             */
            {0, 192, 48, 240, 12, 204, 60, 252, 3, 195, 51, 243, 15, 207, 63, 255},
            {128, 64, 176, 112, 140, 76, 188, 124, 131, 67, 179, 115, 143, 79, 191, 127},
            {32, 224, 16, 208, 44, 236, 28, 220, 35, 227, 19, 211, 47, 239, 31, 223},
            {160, 96, 144, 80, 172, 108, 156, 92, 163, 99, 147, 83, 175, 111, 159, 95},
            {8, 200, 56, 248, 4, 196, 52, 244, 11, 203, 59, 251, 7, 199, 55, 247},
            {136, 72, 184, 120, 132, 68, 180, 116, 139, 75, 187, 123, 135, 71, 183, 119},
            {40, 232, 24, 216, 36, 228, 20, 212, 43, 235, 27, 219, 39, 231, 23, 215},
            {168, 104, 152, 88, 164, 100, 148, 84, 171, 107, 155, 91, 167, 103, 151, 87},
            {2, 194, 50, 242, 14, 206, 62, 254, 1, 193, 49, 241, 13, 205, 61, 253},
            {130, 66, 178, 114, 142, 78, 190, 126, 129, 65, 177, 113, 141, 77, 189, 125},
            {34, 226, 18, 210, 46, 238, 30, 222, 33, 225, 17, 209, 45, 237, 29, 221},
            {162, 98, 146, 82, 174, 110, 158, 94, 161, 97, 145, 81, 173, 109, 157, 93},
            {10, 202, 58, 250, 6, 198, 54, 246, 9, 201, 57, 249, 5, 197, 53, 245},
            {138, 74, 186, 122, 134, 70, 182, 118, 137, 73, 185, 121, 133, 69, 181, 117},
            {42, 234, 26, 218, 38, 230, 22, 214, 41, 233, 25, 217, 37, 229, 21, 213},
            {170, 106, 154, 90, 166, 102, 150, 86, 169, 105, 153, 89, 165, 101, 149, 85}};

    public int sv_actual; /* number of entries in use */

    public short[][] colorindex; //JSAMPARRAY colorindex;    /* Precomputed mapping for speed */
    /* colorindex[i][j] = index of color closest to pixel value j in component i,
     * premultiplied as described above.  Since colormap indexes must fit into
     * JSAMPLEs, the entries of this array will too.
     */
    public boolean is_padded; /* is the colorindex padded for odither? */

    public int[] Ncolors = new int[MAX_Q_COMPS]; /* # of values alloced to each component */

    /* Variables for ordered dithering */
    public int row_index; /* cur row's vertical index in dither matrix */
    public int[][][] oditherptr = new int[MAX_Q_COMPS][][]; /* one dither array per component */
    public int[][] odither = new int[ODITHER_SIZE][ODITHER_SIZE];

    /* Variables for Floyd-Steinberg dithering */
    // FSERROR type int;
    // LOCFSERROR = long;
    // FSERRPTR/FSERROR = int[]
    //FSERRPTR fserrors[MAX_Q_COMPS]; /* accumulated errors */
    int[][] fserrors = new int[MAX_Q_COMPS][];

    public int select_ncolors(jpeg_decompress_struct12_16 cinfo, int[] Ncolors)
        /* Determine allocation of desired colors to components, */
        /* and fill in Ncolors[] array to indicate choice. */
        /* Return value is total number of colors (product of Ncolors[] values). */
    {
        int nc = cinfo.out_color_components; /* number of color components */
        int max_colors = cinfo.desired_number_of_colors;
        int total_colors, iroot, i, j;
        boolean changed;
        long temp;
        int[] RGB_order = {jmorecfg12_16.RGB_GREEN, jmorecfg12_16.RGB_RED, jmorecfg12_16.RGB_BLUE};

        /* We can allocate at least the nc'th root of max_colors per component. */
        /* Compute floor(nc'th root of max_colors). */
        iroot = 1;
        do
        {
            iroot++;
            temp = iroot; /* set temp = iroot ** nc */
            for (i = 1; i < nc; i++)
                temp *= iroot;
        }
        while (temp <= (long) max_colors); /* repeat till iroot exceeds root */
        iroot--; /* now iroot = floor(root) */

        /* Must have at least 2 color values per component */
        if (iroot < 2)
            cinfo.err.ERREXIT1(ErrorStrings12_16.JERR_QUANT_FEW_COLORS, temp);

        /* Initialize to iroot color values for each component */
        total_colors = 1;
        for (i = 0; i < nc; i++)
        {
            Ncolors[i] = iroot;
            total_colors *= iroot;
        }
        /* We may be able to increment the count for one or more components without
         * exceeding max_colors, though we know not all can be incremented.
         * Sometimes, the first component can be incremented more than once!
         * (Example: for 16 colors, we start at 2*2*2, go to 3*2*2, then 4*2*2.)
         * In RGB colorspace, try to increment G first, then R, then B.
         */
        do
        {
            changed = false;
            for (i = 0; i < nc; i++)
            {
                j = (cinfo.out_color_space == jpeglib12_16.J_COLOR_SPACE.JCS_RGB ? RGB_order[i] : i);
                /* calculate new total_colors if Ncolors[j] is incremented */
                temp = total_colors / Ncolors[j];
                temp *= Ncolors[j] + 1; /* done in long arith to avoid oflo */
                if (temp > (long) max_colors)
                    break; /* won't fit, done with this pass */
                Ncolors[j]++; /* OK, apply the increment */
                total_colors = (int) temp;
                changed = true;
            }
        }
        while (changed);

        return total_colors;
    }

    public int output_value(jpeg_decompress_struct12_16 cinfo, int ci, int j, int maxj)
        /* Return j'th output value, where j will range from 0 to maxj */
        /* The output values must fall in 0..jmorecfg.MAXJSAMPLE in increasing order */
    {
        /* We always provide values 0 and jmorecfg.MAXJSAMPLE for each component;
         * any additional values are equally spaced between these limits.
         * (Forcing the upper and lower values to the limits ensures that
         * dithering can't produce a color outside the selected gamut.)
         */
        return ((j * jmorecfg12_16.MAXJSAMPLE + maxj / 2) / maxj);
    }

    public int largest_input_value(jpeg_decompress_struct12_16 cinfo, int ci, int j, int maxj)
        /* Return largest input value that should map to j'th output value */
        /* Must have largest(j=0) >= 0, and largest(j=maxj) >= jmorecfg.MAXJSAMPLE */
    {
        /* Breakpoints are halfway between values returned by output_value */
        return (((2 * j + 1) * jmorecfg12_16.MAXJSAMPLE + maxj) / (2 * maxj));
    }

    /*
     * Create the colormap.
     */
    public void create_colormap(jpeg_decompress_struct12_16 cinfo)
    {
        //my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo.cquantize;
        short[][] colormap; /* Created colormap */
        int total_colors; /* Number of distinct output colors */
        int i, j, k, nci, blksize, blkdist, ptr, val;

        /* Select number of colors for each component */
        total_colors = select_ncolors(cinfo, Ncolors);

        /* Allocate and fill in the colormap. */
        /* The colors are ordered in the map in standard row-major order, */
        /* i.e. rightmost (highest-indexed) color changes most rapidly. */

        colormap = cinfo.mem.alloc_sarray(cinfo, total_colors, cinfo.out_color_components);

        /* blksize is number of adjacent repeated entries for a component */
        /* blkdist is distance between groups of identical entries for a component */
        blkdist = total_colors;

        for (i = 0; i < cinfo.out_color_components; i++)
        {
            /* fill in colormap entries for i'th color component */
            nci = Ncolors[i]; /* # of distinct values for this color */
            blksize = blkdist / nci;
            for (j = 0; j < nci; j++)
            {
                /* Compute j'th output value (out of nci) for component */
                val = output_value(cinfo, i, j, nci - 1);
                /* Fill in all colormap entries that have this value of this component */
                for (ptr = j * blksize; ptr < total_colors; ptr += blkdist)
                {
                    /* fill in blksize entries beginning at ptr */
                    for (k = 0; k < blksize; k++)
                        colormap[i][ptr + k] = (short) val;
                }
            }
            blkdist = blksize; /* blksize of this color is blkdist of next */
        }

        /* Save the colormap in private storage,
         * where it will survive color quantization mode changes.
         */
        sv_colormap = colormap;
        sv_actual = total_colors;
    }

    public void create_colorindex(jpeg_decompress_struct12_16 cinfo)
    {
        int i, j, k, nci, blksize, val, pad;

        /* For ordered dither, we pad the color index tables by jmorecfg.MAXJSAMPLE in
         * each direction (input index values can be -jmorecfg.MAXJSAMPLE .. 2*jmorecfg.MAXJSAMPLE).
         * This is not necessary in the other dithering modes.  However, we
         * flag whether it was done in case user changes dithering mode.
         */
        if (cinfo.dither_mode == jpeglib12_16.J_DITHER_MODE.JDITHER_ORDERED)
        {
            pad = jmorecfg12_16.MAXJSAMPLE * 2;
            is_padded = true;
        }
        else
        {
            pad = 0;
            is_padded = false;
        }

        colorindex = cinfo.mem.alloc_sarray(cinfo, (jmorecfg12_16.MAXJSAMPLE + 1 + pad), cinfo.out_color_components);

        /* blksize is number of adjacent repeated entries for a component */
        blksize = sv_actual;

        for (i = 0; i < cinfo.out_color_components; i++)
        {
            /* fill in colorindex entries for i'th color component */
            nci = Ncolors[i]; /* # of distinct values for this color */
            blksize = blksize / nci;

            /* adjust colorindex pointers to provide padding at negative indexes. */
            // pointer stuff
            if (pad != 0)
            {
                i += jmorecfg12_16.MAXJSAMPLE;
            }

            /* in loop, val = index of current output value, */
            /* and k = largest j that maps to current val */

            val = 0;
            k = largest_input_value(cinfo, i, 0, nci - 1);
            for (j = 0; j <= jmorecfg12_16.MAXJSAMPLE; j++)
            {
                while (j > k) /* advance val if past boundary */
                {
                    k = largest_input_value(cinfo, i, ++val, nci - 1);
                }
                /* premultiply so that no multiplication needed in main processing */
                colorindex[i][j] = (short) (val * blksize);
            }
            /* Pad at both ends if necessary */
            if (!is_padded)
            {
                // TODO - this is not correct
                for (j = 1; j <= jmorecfg12_16.MAXJSAMPLE; j++)
                {
                    colorindex[i][j] = colorindex[i][0];
                    colorindex[i][jmorecfg12_16.MAXJSAMPLE + j] = colorindex[i][jmorecfg12_16.MAXJSAMPLE];
                }
            }
        }
    }

    /*
     * Create an ordered-dither array for a component having ncolors
     * distinct output values.
     */

    public int[][] make_odither_array(jpeg_decompress_struct12_16 cinfo, int ncolors)
    {
        int j, k;
        long num, den;

        /* The inter-value distance for this color is MAXJSAMPLE/(ncolors-1).
         * Hence the dither value for the matrix cell with fill order f
         * (f=0..N-1) should be (N-1-2*f)/(2*N) * MAXJSAMPLE/(ncolors-1).
         * On 16-bit-int machine, be careful to avoid overflow.
         */
        den = 2 * ODITHER_CELLS * ((long) (ncolors - 1));
        for (j = 0; j < ODITHER_SIZE; j++)
        {
            for (k = 0; k < ODITHER_SIZE; k++)
            {
                num = ((long) (ODITHER_CELLS - 1 - 2L * base_dither_matrix[j][k])) * jmorecfg12_16.MAXJSAMPLE;
                /* Ensure round towards zero despite C's lack of consistency
                 * about rounding negative values in integer division...
                 */
                odither[j][k] = (int) (num < 0 ? -((-num) / den) : num / den);
            }
        }
        return odither;
    }

    /*
     * Create the ordered-dither tables.
     * Components having the same number of representative colors may
     * share a dither table.
     */
    public void create_odither_tables(jpeg_decompress_struct12_16 cinfo)
    {
        int[] odither_ptr;
        int i, j, nci;

        for (i = 0; i < cinfo.out_color_components; i++)
        {
            nci = Ncolors[i]; /* # of distinct values for this color */
            odither_ptr = null;     /* search for matching prior component */
            for (j = 0; j < i; j++)
            {
                if (nci == Ncolors[j])
                {
                    odither_ptr = odither[j];
                    break;
                }
            }
            if (odither_ptr == null)    /* need a new table? */
                odither = make_odither_array(cinfo, nci);
            odither[i] = odither_ptr;
        }
    }

    /*
     * Map some rows of pixels to the output colormapped representation.
     */
    @Override
    public void color_quantize(jpeg_decompress_struct12_16 cinfo, short[][] input_buf, short[][] output_buf, int num_rows)
    {
        switch (quant_method)
        {
            case color_quantize -> color_quantize_impl(cinfo, input_buf, output_buf, num_rows);
            case color_quantize3 -> color_quantize3(cinfo, input_buf, output_buf, num_rows);
            case quantize_ord_dither -> quantize_ord_dither(cinfo, input_buf, output_buf, num_rows);
            case quantize3_ord_dither -> quantize3_ord_dither(cinfo, input_buf, output_buf, num_rows);
            case quantize_fs_dither -> quantize_fs_dither(cinfo, input_buf, output_buf, num_rows);
        }
    }

    public void color_quantize_impl(jpeg_decompress_struct12_16 cinfo, short[][] input_buf, short[][] output_buf,
                                    int num_rows)
    {
        /* General case, no dithering */

    }

    public void color_quantize3(jpeg_decompress_struct12_16 cinfo, short[][] input_buf, short[][] output_buf, int num_rows)
        /* Fast path for out_color_components==3, no dithering */
    {

    }

    public void quantize_ord_dither(jpeg_decompress_struct12_16 cinfo, short[][] input_buf, short[][] output_buf, int num_rows)
        /* General case, with ordered dithering */
    {

    }

    public void quantize3_ord_dither(jpeg_decompress_struct12_16 cinfo, short[][] input_buf, short[][] output_buf, int num_rows)
        /* Fast path for out_color_components==3, with ordered dithering */
    {

    }

    //public void quantize_fs_dither(jpeg_decompress_struct cinfo, JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
    public void quantize_fs_dither(jpeg_decompress_struct12_16 cinfo, short[][] input_buf, short[][] output_buf, int num_rows)
    /* General case, with Floyd-Steinberg dithering */
    {

    }

    /*
     * Allocate workspace for Floyd-Steinberg errors.
     */
    public void alloc_fs_workspace(jpeg_decompress_struct12_16 cinfo)
    {
        int arraysize = (cinfo.output_width + 2);
        for (int i = 0; i < cinfo.out_color_components; i++)
        {
            fserrors[i] = new int[arraysize];
        }
    }

    /*
     * Initialize for one-pass color quantization.
     */
    public void start_pass_1_quant(jpeg_decompress_struct12_16 cinfo, boolean is_pre_scan)
    {
        int arraysize;
        int i;

        /* Install my colormap. */
        cinfo.colormap = sv_colormap;
        cinfo.actual_number_of_colors = sv_actual;

        /* Initialize for desired dithering mode. */
        switch (cinfo.dither_mode)
        {
            case JDITHER_NONE:
                if (cinfo.out_color_components == 3)
                    quant_method = QUANT_METHODS.color_quantize3;
                else
                    quant_method = QUANT_METHODS.color_quantize;
                break;
            case JDITHER_ORDERED:
                if (cinfo.out_color_components == 3)
                    quant_method = QUANT_METHODS.quantize3_ord_dither;
                else
                    quant_method = QUANT_METHODS.quantize_ord_dither;
                row_index = 0;   /* initialize state for ordered dither */
                /* If user changed to ordered dither from another mode,
                 * we must recreate the color index table with padding.
                 * This will cost extra space, but probably isn't very likely.
                 */
                if (!is_padded)
                    create_colorindex(cinfo);
                /* Create ordered-dither tables if we didn't already. */
                if (odither[0] == null)
                    create_odither_tables(cinfo);
                break;
            case JDITHER_FS:
                quant_method = QUANT_METHODS.quantize_fs_dither;
                on_odd_row = false; /* initialize state for F-S dither */
                /* Allocate Floyd-Steinberg workspace if didn't already. */
                if (fserrors[0] == null)
                    alloc_fs_workspace(cinfo);
                /* Initialize the propagated errors to zero. */
                arraysize = cinfo.output_width + 2;
                for (i = 0; i < cinfo.out_color_components; i++)
                    fserrors[i] = new int[arraysize];
                break;
            default:
                cinfo.err.ERREXIT(ErrorStrings12_16.JERR_NOT_COMPILED);
                break;
        }
    }

    /*
     * Finish up at the end of the pass.
     */
    public void finish_pass_1_quant(jpeg_decompress_struct12_16 cinfo)
    {
        /* no work in 1-pass case */
    }

    /*
     * Switch to a new external colormap between output passes.
     * Shouldn't get to this module!
     */
    public void new_color_map_1_quant(jpeg_decompress_struct12_16 cinfo)
    {
        cinfo.err.ERREXIT(ErrorStrings12_16.JERR_MODE_CHANGE);
    }

    /*
     * Module initialization routine for 1-pass color quantization.
     */
    public void jinit_1pass_quantizer(jpeg_decompress_struct12_16 cinfo)
    {
        create_colormap(cinfo);
        create_colorindex(cinfo);

        if (cinfo.dither_mode == jpeglib12_16.J_DITHER_MODE.JDITHER_FS)
        {
            alloc_fs_workspace(cinfo);
        }
    }

    @Override
    public void jinit_pass_quantizer(jpeg_decompress_struct12_16 cinfo)
    {
        jinit_1pass_quantizer(cinfo);
    }

    @Override
    public void start_pass(jpeg_decompress_struct12_16 cinfo, boolean is_pre_scan)
    {
        start_pass_1_quant(cinfo, is_pre_scan);
    }

    @Override
    public void finish_pass(jpeg_decompress_struct12_16 cinfo)
    {
        finish_pass_1_quant(cinfo);
    }

    @Override
    public void new_color_map(jpeg_decompress_struct12_16 cinfo)
    {
        new_color_map_1_quant(cinfo);
    }
}
